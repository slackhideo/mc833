\documentclass[a4paper,10pt]{article}
\usepackage[top=2cm, left = 2cm , right=2cm , bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage[brazil]{babel}
%\pagestyle{plain}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=bash,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  literate={á}{{\'a}}1
           {ç}{{\c{c}}}1
           {ü}{{\"u}}1
           {é}{{\'e}}1
}

\lstset{
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

\begin{document}
%\twocolumn


\title{MC833 A - Programação de redes de computadores\\
Relatório - Tarefa 03}

\author {   093125 - Tiago Martinho de Barros - \textit{tiago.ec09@gmail.com}\\
            093175 - Victor Fernando Pompeo Barbosa - \textit{victorfpb@gmail.com}}

%\date{}

\maketitle

\centerline{Prof. Paulo Licio de Geus}
\centerline{IC -- UNICAMP}

\vspace{2cm}
\tableofcontents
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Introdução}
\hspace{14pt}

    Nesta tarefa modificaremos a aplicação Simplex-Talk desenvolvida anteriormente para incluir o suporte a múltiplos clientes simultaneamente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Questão 1}
A função {\tt getsockname} está definida em $\langle sys/socket.h \rangle$ e sua assinatura é:
    \begin{lstlisting}
    int getsockname(int sockfd, struct sockaddr *address, socklen_t *restrict address_len);
    \end{lstlisting}

Ela retorna o endereço atual a que o socket {\tt sockfd} está ligado, no buffer apontado por {\tt address}. O argumento {\tt address\_len} informa o espaço (em bytes) apontado por {\tt address}; quando a função retorna, {\tt address\_len} é sobrescrito com o tamanho real do endereço do socket.

Para que o programa {\tt client.c} passasse a obter os valores de IP e porta do socket local e os imprimisse na saída padrão, o seguinte trecho de código foi adicionado ao programa:

\begin{lstlisting}
    struct sockaddr_in local;
    unsigned int locallen;

    locallen = sizeof(local);
    if (getsockname(s, (struct sockaddr *)&local, &locallen) < 0) {
        perror("simplex-talk: getsockname");
        close(s);
        exit(1);
    }

    fprintf(stdout, "-------------------\n");
    fprintf(stdout, "IP local: %s\n", inet_ntoa(local.sin_addr));
    fprintf(stdout, "Porta local: %d\n", ntohs(local.sin_port));
    fprintf(stdout, "-------------------\n\n");

\end{lstlisting}

\section{Questão 2}
A função {\tt getpeername} está definida em $\langle sys/socket.h \rangle$ e sua assinatura é:
    \begin{lstlisting}
    int getpeername(int sockfd, struct sockaddr *address, socklen_t *restrict address_len);
    \end{lstlisting}

Ela retorna o endereço do peer conectado ao socket {\tt sockfd}, no buffer apontado por {\tt address}. O argumento {\tt address\_len} informa o espaço (em bytes) apontado por {\tt address}; quando a função retorna, {\tt address\_len} é sobrescrito com o tamanho real do endereço do socket.

Para que o programa {\tt server.c} passasse a obter os valores de IP e porta do socket local e os imprimisse na saída padrão, o seguinte trecho de código foi adicionado ao programa:

\begin{lstlisting}
    struct sockaddr_in peer;
    unsigned int peerlen;

    peerlen = sizeof(peer);
    if (getpeername(new_s, (struct sockaddr *)&peer, &peerlen) < 0) {
        perror("simplex-talk: getpeername");
        exit(1);
    }

    fprintf(stdout, "--------------------\n");
    fprintf(stdout, "IP remoto: %s\n", inet_ntoa(peer.sin_addr));
    fprintf(stdout, "Porta remota: %d\n", ntohs(peer.sin_port));
    fprintf(stdout, "--------------------\n\n");

\end{lstlisting}

\section{Questão 3}
Para que o servidor pudesse atender mais de um cliente, o loop principal foi alterado. A nova versão está copiada a seguir.

\begin{lstlisting}
for( ; ; ) {
        len = sizeof(sin);
        if ((new_s = accept(s, (struct sockaddr *)&sin, &len)) < 0) {
            perror("simplex-talk: accept");
            exit(1);
        }

        //do this if child
        if((pid = fork()) == 0) {
            close(s);

            peerlen = sizeof(peer);
            if (getpeername(new_s, (struct sockaddr *)&peer, &peerlen) < 0) {
                perror("simplex-talk: getpeername");
                exit(1);
            }

            fprintf(stdout, "--------------------\n");
            fprintf(stdout, "IP remoto: %s\n", inet_ntoa(peer.sin_addr));
            fprintf(stdout, "Porta remota: %d\n", ntohs(peer.sin_port));
            fprintf(stdout, "--------------------\n\n");

            while ((len = recv(new_s, buf, sizeof(buf), 0))) {
                fputs(buf, stdout);
                if ((send(new_s, buf, strlen(buf)+1, 0)) < 0) {
                    perror("simplex-talk: send");
                    exit(1);
                }
            }

            //close child connection
            close(new_s);
            exit(0);
        }

        //close parent connection (the child owns this socket now)
        close(new_s);
    }
    
\end{lstlisting}

O primeiro trecho aceita uma nova conexão; em seguida, o processo pai utiliza {\tt fork} para criar processos filhos. A função {\tt fork} tem dois tipos de retorno diferentes, no caso de sucesso: para o pai, ela retorna o PID do filho; para o filho, ela retorna zero. Dessa maneira, o trecho {\tt if((pid = fork()) == 0)} certifica-se que aquele bloco de código apenas será executado pelo processo filho (já que o pai só será utilizado para distribuir as conexões).

O bloco de código seguinte lida com a conexão da mesma forma que o Simplex-talk não concorrente, com as modificações propostas pela Questão 1.

Por fim, o processo filho fecha a conexão estabelecida antes de invocar {\tt exit(0)}.

\section{Questão 4}
No início do bloco de código {\tt if} que é executado apenas no processo filho, o comando {\tt close(s)} fecha o descritor de arquivo do socket utilizado pelo processo pai, já que, quando {\tt fork} foi invocada, os descritores foram duplicados. Dessa maneira, o processo pai não perde acesso ao descritor. Antes de invocar {\tt exit(0)}, o filho também fecha o descritor do socket que estava utilizando.

De maneira similar, após passar o controle da conexão ao processo filho, o pai utiliza {\tt close(new\_s)} para fechar o descritor de arquivo do socket que passou a ser utilizado pelo filho.

\section{Questão 5}
O servidor foi inicializado, recebendo conexões de 3 clientes diferentes. A saída do terminal referente ao processo do servidor está exibida a seguir.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ ./server 
--------------------
IP remoto: 127.0.0.1
Porta remota: 44701
--------------------

--------------------
IP remoto: 127.0.0.1
Porta remota: 44702
--------------------

--------------------
IP remoto: 127.0.0.1
Porta remota: 44703
--------------------

Olá, este é o cliente 1
Olá, este é o cliente 2
Olá, este é o cliente 3
Mensagem
Mensagem 2
Mensagem maior 3

\end{lstlisting}

A saída referente ao primeiro cliente pode ser verificada a seguir.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ ./client localhost
-------------------
IP local: 127.0.0.1
Porta local: 44701
-------------------

Olá, este é o cliente 1
Olá, este é o cliente 1

Mensagem
Mensagem

\end{lstlisting}

A saída referente ao segundo cliente foi copiada a seguir.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ ./client localhost
-------------------
IP local: 127.0.0.1
Porta local: 44702
-------------------

Olá, este é o cliente 2
Olá, este é o cliente 2

Mensagem 2
Mensagem 2

\end{lstlisting}

A saída referente ao terceiro cliente está exibida a seguir.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ ./client localhost
-------------------
IP local: 127.0.0.1
Porta local: 44703
-------------------

Olá, este é o cliente 3
Olá, este é o cliente 3

Mensagem maior 3
Mensagem maior 3


\end{lstlisting}

Com auxílio do comando {\tt tcpdump}, pode-se verificar a simultaneidade da comunicação. A saída do comando está listada a seguir.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ sudo tcpdump -i lo
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
05:08:05.426916 IP localhost.53969 > ubuntu.domain: 41863+ A? clients6.google.com. (37)
05:08:05.427668 IP localhost.52385 > ubuntu.domain: 47897+ A? clients6.google.com. (37)
05:08:05.428055 IP localhost.53969 > ubuntu.domain: 43805+ AAAA? clients6.google.com. (37)
05:08:05.431572 IP ubuntu.domain > localhost.52385: 47897 2/0/0 CNAME clients.l.google.com., A 216.58.202.14 (77)
05:08:05.432303 IP ubuntu.domain > localhost.53969: 41863 2/0/0 CNAME clients.l.google.com., A 216.58.202.110 (77)
05:08:05.432322 IP ubuntu.domain > localhost.53969: 43805 2/0/0 CNAME clients.l.google.com., AAAA 2800:3f0:4001:802::200e (89)
05:08:07.505300 IP localhost.34316 > ubuntu.domain: 63144+ A? papeeria.com. (30)
05:08:07.505585 IP localhost.34316 > ubuntu.domain: 56989+ AAAA? papeeria.com. (30)
05:08:07.509576 IP ubuntu.domain > localhost.34316: 56989 0/1/0 (120)
05:08:07.646802 IP ubuntu.domain > localhost.34316: 63144 1/0/0 A 104.155.84.196 (46)
05:08:07.955545 IP localhost.41523 > ubuntu.domain: 25499+ A? 9.client-channel.google.com. (45)
05:08:07.955703 IP localhost.41523 > ubuntu.domain: 35634+ AAAA? 9.client-channel.google.com. (45)
05:08:07.959390 IP ubuntu.domain > localhost.41523: 25499 1/0/0 A 64.233.186.189 (61)
05:08:08.019215 IP ubuntu.domain > localhost.41523: 35634 1/0/0 AAAA 2800:3f0:4003:c00::bd (73)
05:08:10.680352 IP localhost.44701 > localhost.31472: Flags [P.], seq 1633950332:1633950359, ack 3085582067, win 342, options [nop,nop,TS val 29836557 ecr 29821421], length 27
05:08:10.680375 IP localhost.31472 > localhost.44701: Flags [.], ack 27, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 0
05:08:10.680410 IP localhost.31472 > localhost.44701: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 27
05:08:10.680418 IP localhost.44701 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 0
05:08:16.715667 IP localhost.44702 > localhost.31472: Flags [P.], seq 1829745820:1829745847, ack 2956712519, win 342, options [nop,nop,TS val 29838066 ecr 29826187], length 27
05:08:16.715689 IP localhost.31472 > localhost.44702: Flags [.], ack 27, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 0
05:08:16.715726 IP localhost.31472 > localhost.44702: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 27
05:08:16.715733 IP localhost.44702 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 0
05:08:21.390036 IP localhost.44703 > localhost.31472: Flags [P.], seq 3661452941:3661452968, ack 3267803020, win 342, options [nop,nop,TS val 29839235 ecr 29827482], length 27
05:08:21.390061 IP localhost.31472 > localhost.44703: Flags [.], ack 27, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 0
05:08:21.390106 IP localhost.31472 > localhost.44703: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 27
05:08:21.390113 IP localhost.44703 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 0
05:08:33.146988 IP localhost.44701 > localhost.31472: Flags [P.], seq 27:37, ack 28, win 342, options [nop,nop,TS val 29842174 ecr 29836557], length 10
05:08:33.147029 IP localhost.31472 > localhost.44701: Flags [P.], seq 28:38, ack 37, win 342, options [nop,nop,TS val 29842174 ecr 29842174], length 10
05:08:33.147040 IP localhost.44701 > localhost.31472: Flags [.], ack 38, win 342, options [nop,nop,TS val 29842174 ecr 29842174], length 0
05:08:37.440119 IP localhost.44702 > localhost.31472: Flags [P.], seq 27:39, ack 28, win 342, options [nop,nop,TS val 29843247 ecr 29838066], length 12
05:08:37.440166 IP localhost.31472 > localhost.44702: Flags [P.], seq 28:40, ack 39, win 342, options [nop,nop,TS val 29843247 ecr 29843247], length 12
05:08:37.440176 IP localhost.44702 > localhost.31472: Flags [.], ack 40, win 342, options [nop,nop,TS val 29843247 ecr 29843247], length 0
05:08:42.169642 IP localhost.44703 > localhost.31472: Flags [P.], seq 27:45, ack 28, win 342, options [nop,nop,TS val 29844429 ecr 29839235], length 18
05:08:42.169742 IP localhost.31472 > localhost.44703: Flags [P.], seq 28:46, ack 45, win 342, options [nop,nop,TS val 29844430 ecr 29844429], length 18
05:08:42.169759 IP localhost.44703 > localhost.31472: Flags [.], ack 46, win 342, options [nop,nop,TS val 29844430 ecr 29844430], length 0
^C
35 packets captured
70 packets received by filter
0 packets dropped by kernel

\end{lstlisting}

Suprimindo as linhas referentes a conexões de outros processos, podemos analisar melhor a comunicação entre servidor/cliente de nosso Simplex-Talk.

\begin{lstlisting}
niko@ubuntu:~/Desktop/mc833/t4$ sudo tcpdump -i lo
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
05:08:10.680352 IP localhost.44701 > localhost.31472: Flags [P.], seq 1633950332:1633950359, ack 3085582067, win 342, options [nop,nop,TS val 29836557 ecr 29821421], length 27
05:08:10.680375 IP localhost.31472 > localhost.44701: Flags [.], ack 27, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 0
05:08:10.680410 IP localhost.31472 > localhost.44701: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 27
05:08:10.680418 IP localhost.44701 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29836557 ecr 29836557], length 0
05:08:16.715667 IP localhost.44702 > localhost.31472: Flags [P.], seq 1829745820:1829745847, ack 2956712519, win 342, options [nop,nop,TS val 29838066 ecr 29826187], length 27
05:08:16.715689 IP localhost.31472 > localhost.44702: Flags [.], ack 27, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 0
05:08:16.715726 IP localhost.31472 > localhost.44702: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 27
05:08:16.715733 IP localhost.44702 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29838066 ecr 29838066], length 0
05:08:21.390036 IP localhost.44703 > localhost.31472: Flags [P.], seq 3661452941:3661452968, ack 3267803020, win 342, options [nop,nop,TS val 29839235 ecr 29827482], length 27
05:08:21.390061 IP localhost.31472 > localhost.44703: Flags [.], ack 27, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 0
05:08:21.390106 IP localhost.31472 > localhost.44703: Flags [P.], seq 1:28, ack 27, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 27
05:08:21.390113 IP localhost.44703 > localhost.31472: Flags [.], ack 28, win 342, options [nop,nop,TS val 29839235 ecr 29839235], length 0
05:08:33.146988 IP localhost.44701 > localhost.31472: Flags [P.], seq 27:37, ack 28, win 342, options [nop,nop,TS val 29842174 ecr 29836557], length 10
05:08:33.147029 IP localhost.31472 > localhost.44701: Flags [P.], seq 28:38, ack 37, win 342, options [nop,nop,TS val 29842174 ecr 29842174], length 10
05:08:33.147040 IP localhost.44701 > localhost.31472: Flags [.], ack 38, win 342, options [nop,nop,TS val 29842174 ecr 29842174], length 0
05:08:37.440119 IP localhost.44702 > localhost.31472: Flags [P.], seq 27:39, ack 28, win 342, options [nop,nop,TS val 29843247 ecr 29838066], length 12
05:08:37.440166 IP localhost.31472 > localhost.44702: Flags [P.], seq 28:40, ack 39, win 342, options [nop,nop,TS val 29843247 ecr 29843247], length 12
05:08:37.440176 IP localhost.44702 > localhost.31472: Flags [.], ack 40, win 342, options [nop,nop,TS val 29843247 ecr 29843247], length 0
05:08:42.169642 IP localhost.44703 > localhost.31472: Flags [P.], seq 27:45, ack 28, win 342, options [nop,nop,TS val 29844429 ecr 29839235], length 18
05:08:42.169742 IP localhost.31472 > localhost.44703: Flags [P.], seq 28:46, ack 45, win 342, options [nop,nop,TS val 29844430 ecr 29844429], length 18
05:08:42.169759 IP localhost.44703 > localhost.31472: Flags [.], ack 46, win 342, options [nop,nop,TS val 29844430 ecr 29844430], length 0
^C
35 packets captured
70 packets received by filter
0 packets dropped by kernel

\end{lstlisting}

Como pode-se verificar, a comunicação se dá exatamente entre as portas utilizadas pelo servidor e por cada um dos processos clientes, e possuem exatamente o mesmo tamanho das mensagens enviadas.



\section{Questão 6}


\end{document}

